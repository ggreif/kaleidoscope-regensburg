* Tasks
** DONE digest [[http://orgmode.org/worg/org-tutorials/orgtutorial_dto.html][org-mode tutorial]]
** DONE integrate [[https://gist.github.com/reetinder/4022989][literate haskell in org-mode]] (does not work, too old?)
** DONE describe the data Void <--> forall a . a isomorphism
** TODO open interpretation, e.g. circuit as Haskell function or VHDL module

* Preliminaries

HOWTO: literate haskell in org-mode:
https://gist.github.com/reetinder/4022989


* Finally-tagless representation

Let's consider the "finally" thingy first.

represent AST nodes with functions alone

our expression is "(3 + 4^2) * 2"

> {-# LANGUAGE TypeSynonymInstances, FlexibleInstances
>   , GeneralizedNewtypeDeriving, MultiParamTypeClasses #-}
> {-# LANGUAGE RankNTypes, LambdaCase, EmptyCase #-}
> import Prelude hiding ((**))
> p ** n = product $ replicate (fromInteger n) (toInteger p)

> {-
> plus, times, power :: Integer -> Integer -> Integer
> (plus, times, power) = ((+), (*), (**))

Constants are just themselves (for now)

Now manually transcribe our expression

> expr = (3 `plus` (4 `power` 2)) `times` 2

clearly we can just ask GHCi for the result:

*Main> expr
38

We can think of our AST being encoded by functions and the "evaluator"
just the identity:

> interpr'Integer = id

*Main> interpr'Integer expr
38

A very strange interpreter!

> -}

Background: 'invented' by Reynolds in the 1970's.

** First refinement of the idea

Let's make this a bit more useful.

> {-
> plus, times, power :: repr -> repr -> repr
> (plus, times, power) = (undefined, undefined, undefined)
> -}

Expr stays the same:

> -- expr = (3 `plus` (4 `power` 2)) `times` (2 :: Integer)

But of course evaluating it does not make lot of a sense:

*Main> expr
 *** Exception: Prelude.undefined

The representation type is so general it is totally useless!
So increase its utility by _restricting generality_.

Define a type class Arith:

> {-
> class Arith repr where
>   plus, times, power :: repr -> repr -> repr

and give it our first implementation for repr ~ Integer:

> instance Arith Integer where
>   plus = (+)
>   times = (*)
>   power = (**)

*Main> expr :: Integer
38

> -}

** Adding another interpretation

Just like the *evaluation* semantics above we can add a printing semantics
by overloading our vocabulary to yield a string representation.

But for this to work we cannot reuse our nullary Integers any more,
we need an injection into the representation:

> -- {-
> class Arith repr where
>   lit :: Integer -> repr
>   plus, times, power :: repr -> repr -> repr


> instance Arith String where
>   lit = show
>   plus a b = "(" ++ a ++ " + " ++ b ++ ")"
>   times a b = "(" ++ a ++ " * " ++ b ++ ")" -- dito
>   power a b = "(" ++ a ++ " ** " ++ b ++ ")" -- dito

> expr :: Arith a => a
> expr = (lit 3 `plus` (lit 4 `power` lit 2)) `times` lit 2

*Main> expr :: String
"((3 + (4 ** 2)) * 2)"


By adding a new type instance we can reinterpret our representation
in arbitrarily many ways.

Let's consider a pretty printer which passes context, i.e. the current
precedence level to eliminate superfluous parentheses:

> {-
> newtype Prec = P (Int -> String)

> instance Arith Prec where
>   lit = show
>   plus a b = "(" ++ a ++ " + " ++ b ++ ")"
>   times a b = "(" ++ a ++ " * " ++ b ++ ")" -- dito
>   power a b = "(" ++ a ++ " ** " ++ b ++ ")" -- dito
> -}
> -- -}

*** TODO finish up above

The general pattern for passing in contextual information is by
employing a (newtype of a) function type for representation type.

** An Analysis

We could come up with diagrams or some other algorithm, e.g. an analysis:

Count operators in the expression tree

> newtype Count = C Int deriving (Num, Show)

> instance Arith Count where
>   lit _ = 0
>   plus (C a) (C b) = C (a + b + 1)
>   times = plus
>   power = plus

** Interlude

A "final" type

> type TotallyPoly = forall a . a

can be considered 100% entropy, while

> data Void -- no constructors

an "initial" type as 0% knowledge.

They are the same thing, as we can convert one to the other:

> p2v :: TotallyPoly -> Void
> p2v a = a

and back:

> v2p :: Void -> TotallyPoly
> v2p = \case {}

** Adding a Type System

So far we could only express terms in the numeric fragment,
let's add a conditional fragment.

Here we have a second data domain, the booleans:

> class Cond b where
>   cmp :: Arith n => n -> n -> b
>   if' :: b -> x -> x -> x

> exprB :: (Arith a, Cond a) => a
> exprB = if' ((lit 3 `cmp` lit 4 :: Arith a => a) :: Cond a => a) expr (expr `plus` lit 1)
