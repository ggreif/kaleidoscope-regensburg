* Preliminaries

HOWTO: literate haskell in org-mode:
https://gist.github.com/reetinder/4022989


* Finally-tagless representation

Let's consider the "finally" thingy first.

represent AST nodes with functions alone

our expression is "(3 + 4^2) * 2"

> -- {-
> plus, times, power :: Integer -> Integer -> Integer
> (plus, times, power) = ((+), (*), (**))

Constants are just themselves (for now)

Now manually transcribe our expression

> expr = (3 `plus` (4 `power` 2)) `times` 2

clearly we can just ask GHCi for the result:

*Main> expr
38

We can think of our AST being encoded by functions and the "evaluator"
just the identity:

> interpr'Integer = id

*Main> interpr'Integer expr
38

> -- -}

A very strange interpreter!

Background: 'invented' by Reynolds in the 1970's.

** First refinement of the idea

Let's make this a bit more useful.

> -- {-
> plus, times, power :: repr -> repr -> repr
> (plus, times, power) = (undefined, undefined, undefined)

Expr stays the same:

> expr = (3 `plus` (4 `power` 2)) `times` 2

> But of course evaluating it does not make lot of a sense:

*Main> undefined
 *** Exception: Prelude.undefined

The representation type is so general it is totally useless!
So increase its utility by _restricting generality_.

Define a type class Arith:

> class Arith repr where
>   plus, times, power :: repr -> repr -> repr

and give it our first implementation for repr ~ Integer:

> instance Arith Integer where
>   plus = (+)
>   times = (*)
>   power = (**)

*Main> expr :: Integer
38

> -- -}
